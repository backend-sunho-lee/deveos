<!doctype html>
<html>
<body>
<p><img src='/Users/sunny/deveos/posts/img/썸네일/9_반복자와_조건문_데이터추가.jpg' alt='thumbnail09' referrerPolicy='no-referrer' /></p>
<p>안녕하세요! <a href='https://deveos.org/'>DEVEOS</a>의 블록체인 개발자 써니입니다☀️</p>
<p>&nbsp;</p>
<p>지난편에서 함수에 테이블 구조체를 객체화하는 것까지 해보았습니다. 그리고 오늘은 다양한 문법들을 활용하여 데이터를 추가하고 수정하는 함수를 마무리하도록 하겠습니다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>iterator 선언</h2>
<pre><code class='language-c++' lang='c++'>void upsert(name user, string first_name, string last_name, string street, string city, string state) {
    address_index addresses(_code, _code.value);	// 객체화
    auto iterator = addresses.find(user.value);		// 반복자 선언
}
</code></pre>
<p><code>iterator</code> 반복자 변수에 매개변수로 받은 <code>user</code> 값이 <code>addresses</code> 테이블에 존재하는지 찾는(<code>find</code>) 문장을 추가합니다.</p>
<p>&nbsp;</p>
<h3>변수 선언</h3>
<pre><code class='language-c++' lang='c++'>데이터타입 변수명 = 값;
</code></pre>
<p>변수를 선언하는 방법 중 하나이며, &#39;변수 초기화&#39;라고도 표현합니다.</p>
<ul>
<li><p>auto</p>
<p>auto를 사용하면 변수를 선언할 때 특정 데이터타입을 지정하지 않아도 됩니다. auto가 자동으로 변수에  맞게 데이터 타입을 지정합니다.</p>
</li>

</ul>
<p>&nbsp;</p>
<h3>iterator (반복자)</h3>
<p><img src='/Users/sunny/deveos/posts/img/iterator.png' alt='iterator' referrerPolicy='no-referrer' /></p>
<p>반복자는 저장되어있는 요소들을 읽어오는 방법입니다. 객체 지향적 프로그래밍에서 배열이나 그와 유사한 자료구조의 내부 요소를 순회하는 객체를 의미합니다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>테이블 객체화를 하는 과정까지 해냈습니다. 그 다음으로, <code>find</code> 함수의 결과로 <code>user</code> 가 존재하지 않는다면 새로운 데이터를 추가하고 존재한다면 데이터 값을 수정하는 로직을 코드로 작성해보도록 하겠습니다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>조건문, if...else</h2>
<pre><code class='language-c++' lang='c++'>void upsert(name user, string first_name, string last_name, string street, string city, string state) {
    address_index addresses(_code, _code.value);
    auto iterator = addresses.find(user.value);
    
    if( iterator == addresses.end() ) {
        //The user isn&#39;t in the table
    } else {
        //The user is in the table
    }
  }
</code></pre>
<p>조건문은 조건의 참/거짓(True/False)에 따라 달라지는 계산이나 상황을 수행하는 프로그래밍 문법입니다. </p>
<pre><code class='language-c++' lang='c++'>if ( 조건식 ) {
    // 조건이 참이라면 실행할 코드 입력
} else {
    // 조건이 것짓이라면 실행할 코드 입력
}
</code></pre>
<p>조건식은 <code>A == B</code>, <code>A != B</code> 와 같이 다양한 등식으로 표현할 수 있는데요. <code>==</code> 는 A와 B가 일치함을, <code>!=</code> 는 일치하지 않음을 의미합니다. </p>
<blockquote><p>예시</p>
<pre><code class='language-c++' lang='c++'>int num = 10;

if (num == 10) {
    printf(&quot;10입니다&quot;)
} else {
    printf(&quot;10이 아닙니다&quot;)
}
</code></pre>
<p><code>num</code> 변수가 10이 맞다면(True) &quot;10입니다&quot;를 출력하고, 10이 아니라면 &quot;10이 아닙니다&quot;를 출력하는 조건문입니다.</p>
</blockquote>
<p>&nbsp;</p>
<pre><code class='language-c++' lang='c++'>if ( iterator == addresses.end() )
</code></pre>
<p>iterator 변수는 <code>addresses</code> 에서 <code>user</code> 를 찾은 결과를 가리키고 있고, <code>end()</code>는 addresses 테이블이 빈값이냐를 알려주는 함수입니다.</p>
<p>그러므로 이 조건문은 iterator가 빈값이면 참(True), 빈값이 아니라면 거짓(False)을 반환합니다. </p>
<p>iterator가 빈값이라면 <code>user</code> 는 테이블에 존재하지 않는 것을 의미하며, 우리는 새로운 데이터를 테이블에 넣어주고, iterator가 특정 데이터 값을 갖고있다면 이미 존재하는 <code>user</code> 이므로 해당 레코드 값을 수정해주는 코드를 작성합니다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>record 추가</h2>
<pre><code class='language-c++' lang='c++'>if( iterator == addresses.end() )
{
    addresses.emplace(user, [&amp;]( auto&amp; row ) {
        row.key = user;
        row.first_name = first_name;
        row.last_name = last_name;
        row.street = street;
        row.city = city;
    });
}
</code></pre>
<p><code>user</code> 가 <code>addresses</code> 테이블에 존재하지 않는 경우, 새로운 데이터를 추가합니다.</p>
<p>&nbsp;</p>
<pre><code class='language-c++' lang='c++'>addresses.emplace(user, [&amp;]( auto&amp; row )
</code></pre>
<p><code>emplace(payer, 람다함수)</code> 는 테이블에 데이터를 추가하는 함수입니다. EOS는 데이터를 RAM에 저장하는데 이 때 비용이 발생합니다. 그 비용을 지불하는 사람을 <code>payer</code> 로 선언합니다.  <code>user</code> 가 비용을 지불하도록 작성합니다.</p>
<ul>
<li><p>람다함수 (Lambda)</p>
<p>람다함수는 몸통은 존재하지만 이름은 없는 함수로 익명함수라고도 합니다. C++에서는 참조자를 간단히 만들기위한 목적으로도 쓰입니다.</p>
</li>
<li><p>&amp; (참조)</p>
<p><code>&amp;</code> 특수문자는 &#39;참조&#39;를 의미합니니다. C++하면 포인터와 참조가 클래스만큼 중요한 요소입니다. 포인터는 주소를 가리키는 것이고 참조는 변수에 별명을 붙여서 변수를 다른 이름으로 부르는 것입니다.</p>
</li>

</ul>
<p>&nbsp;</p>
<p><code>row</code>  변수는 테이블의 빈 레코드입니다. key, first_name, last_name, street, city의 값이 비어있는 행을 가리킵니다.</p>
<pre><code class='language-c++' lang='c++'>row.key = user;
</code></pre>
<p>객체의 멤버에 값을 채워넣어줍니다. </p>
<p>클래스는 멤버로 구성되어 있으며, 객체화를 하면 객체의 멤버를 호출할 수 있습니다. 멤버를 호출하는 방법은 <code>객체.멤버</code> , <code>객체::멤버</code> 등이 있습니다. 그래서 빈레코드의 <code>key</code> 필드에 <code>user</code> 라는 값을 넣어줍니다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>record 수정</h2>
<pre><code class='language-c++' lang='c++'>else {
    addresses.modify(iterator, user, [&amp;]( auto&amp; row ) {
        row.key = user;
        row.first_name = first_name;
        row.last_name = last_name;
        row.street = street;
        row.city = city;
    });
}
</code></pre>
<p><code>user</code> 가 <code>addresses</code> 테이블에 존재하는 경우, 데이터 값을 수정합니다.</p>
<p>&nbsp;</p>
<pre><code class='language-c++' lang='c++'>addresses.modify(iterator, user, [&amp;]( auto&amp; row )
</code></pre>
<p><code>modify(itr, payer, 람다함수)</code> 는 단어 그대로 수정을 의미하는 함수입니다. <code>itr</code> 는 수정할 대상을 의미하며 이 코드에서는 수정할 <code>user</code> 를 가리키는 iterator를 넣어줍니다. 나머지는 <code>emplace()</code> 와 동일합니다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>이제 <code>addressbook</code> 컨트랙트에는 record가 없으면 추가하고 이미 존재하는 경우 수정할 수 있는 <code>upsert</code> 액션이 추가되었습니다. </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre><code class='language-c++' lang='c++'>#include &lt;eosiolib/eosio.hpp&gt;

using namespace eosio;
using namespace std;

class [[eosio::contract]] addressbook : public contract {

private:
  struct [[eosio::table]] person {
    name key;
    string first_name;
    string last_name;
    string street;
    string city;
    
    uint64_t primary_key() const { return key.value; }
  };
  typedef eosio::multi_index&lt;&quot;people&quot;_n, person&gt; address_index;

public:
  //using contract::contract;
  addressbook(name receiver, name code, datastream&lt;const char*&gt; ds):contract(receiver, code, ds) {}

  [[eosio::action]]
  void upsert(name user, string first_name, string last_name, string street, string city, string state) {
    address_index addresses(_code, _code.value);
    auto iterator = addresses.find(user.value);
    if( iterator == addresses.end() )
    {
      addresses.emplace(user, [&amp;]( auto&amp; row ) {
       row.key = user;
       row.first_name = first_name;
       row.last_name = last_name;
       row.street = street;
       row.city = city;
      });
    }
    else {
      addresses.modify(iterator, user, [&amp;]( auto&amp; row ) {
        row.key = user;
        row.first_name = first_name;
        row.last_name = last_name;
        row.street = street;
        row.city = city;
      });
    }
  }

};

EOSIO_DISPATCH( addressbook, (upsert))
</code></pre>
<p>주소록 스마트 컨트랙트 작성을 마쳤네요! 이제 한 문장문장 왜 필요한지 무슨 뜻인지 읽혀지지 않나요? </p>
<p>뿌듯하죠? (강요)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>다음편에서는 컴파일을 통하여 오류는 없는지, WASM으로 변환하는 과정을 해보도록 하겠습니다.</p>
</body>
</html>
